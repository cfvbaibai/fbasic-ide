/**
 * F-Basic AST (Abstract Syntax Tree) Node Types
 * 
 * These interfaces define the structure of the AST generated by the F-Basic parser.
 * They provide type safety for the interpreter and syntax highlighter.
 * 
 * This file matches the fbasic-grammar-minimal.pegjs grammar definition.
 */

// Base AST Node
export interface ASTNode {
  type: string;
  [key: string]: unknown;
}

// Program AST
export interface ProgramNode extends ASTNode {
  type: 'Program';
  statements: StatementNode[];
}

// Statement AST
export interface StatementNode extends ASTNode {
  type: 'Statement';
  lineNumber: number;
  command: CommandNode;
}

// Command AST Nodes
export type CommandNode = 
  | PrintStatementNode
  | LetStatementNode
  | IfStatementNode
  | ForStatementNode
  | NextStatementNode
  | GotoStatementNode
  | GosubStatementNode
  | ReturnStatementNode
  | EndStatementNode
  | InputStatementNode
  | DataStatementNode
  | ReadStatementNode
  | RestoreStatementNode
  | DimStatementNode
  | DefStatementNode
  | RemStatementNode
  | ClsStatementNode
  | ColorStatementNode
  | PsetStatementNode
  | LineStatementNode
  | CircleStatementNode
  | PaintStatementNode
  | StatementBlockNode
  | StatementBlockExecutorNode
  | InvalidCommandNode;

// PRINT Statement
export interface PrintStatementNode extends ASTNode {
  type: 'PrintStatement';
  printList: PrintItemNode[];
}

export type PrintItemNode = ExpressionNode | StringLiteralNode;

// LET Statement
export interface LetStatementNode extends ASTNode {
  type: 'LetStatement';
  variable: VariableNode;
  expression: ExpressionNode;
  hasLetKeyword: boolean;
}

// IF Statement
export interface IfStatementNode extends ASTNode {
  type: 'IfStatement';
  condition: ExpressionNode;
  thenStatement: CommandNode;
}

// Statement Block (for multi-statement THEN clauses)
export interface StatementBlockNode extends ASTNode {
  type: 'StatementBlock';
  statements: CommandNode[];
}

// Statement Block Executor (for processed nested StatementBlocks)
export interface StatementBlockExecutorNode extends ASTNode {
  type: 'StatementBlockExecutor';
  statements: CommandNode[];
}

// FOR Statement
export interface ForStatementNode extends ASTNode {
  type: 'ForStatement';
  variable: VariableNode;
  start: ExpressionNode;
  end: ExpressionNode;
  step: ExpressionNode;
}

// NEXT Statement
export interface NextStatementNode extends ASTNode {
  type: 'NextStatement';
  variable: VariableNode | null;
}

// GOTO Statement
export interface GotoStatementNode extends ASTNode {
  type: 'GotoStatement';
  target: ExpressionNode;
}

// GOSUB Statement
export interface GosubStatementNode extends ASTNode {
  type: 'GosubStatement';
  target: ExpressionNode;
}

// RETURN Statement
export interface ReturnStatementNode extends ASTNode {
  type: 'ReturnStatement';
}

// END Statement
export interface EndStatementNode extends ASTNode {
  type: 'EndStatement';
}

// INPUT Statement
export interface InputStatementNode extends ASTNode {
  type: 'InputStatement';
  prompt: StringLiteralNode | null;
  variables: VariableNode[];
}

// DATA Statement
export interface DataStatementNode extends ASTNode {
  type: 'DataStatement';
  constants: ConstantNode[];
}

export type ConstantNode = NumberLiteralNode | StringLiteralNode;

// READ Statement
export interface ReadStatementNode extends ASTNode {
  type: 'ReadStatement';
  variables: VariableNode[];
}

// RESTORE Statement
export interface RestoreStatementNode extends ASTNode {
  type: 'RestoreStatement';
  lineNumber: ExpressionNode | null;
}

// DIM Statement
export interface DimStatementNode extends ASTNode {
  type: 'DimStatement';
  arrays: ArrayDeclarationNode[];
}

export interface ArrayDeclarationNode extends ASTNode {
  variable: VariableNode;
  dimensions: ExpressionNode[];
}

// DEF Statement
export interface DefStatementNode extends ASTNode {
  type: 'DefStatement';
  name: string;
  parameter: VariableNode;
  expression: ExpressionNode;
}

// REM Statement
export interface RemStatementNode extends ASTNode {
  type: 'RemStatement';
  comment: string;
}

// CLS Statement
export interface ClsStatementNode extends ASTNode {
  type: 'ClsStatement';
}

// COLOR Statement
export interface ColorStatementNode extends ASTNode {
  type: 'ColorStatement';
  foreground: ExpressionNode;
  background: ExpressionNode | null;
}

// PSET Statement
export interface PsetStatementNode extends ASTNode {
  type: 'PsetStatement';
  x: ExpressionNode;
  y: ExpressionNode;
  color: ExpressionNode | null;
}

// LINE Statement
export interface LineStatementNode extends ASTNode {
  type: 'LineStatement';
  x1: ExpressionNode;
  y1: ExpressionNode;
  x2: ExpressionNode;
  y2: ExpressionNode;
  color: ExpressionNode | null;
}

// CIRCLE Statement
export interface CircleStatementNode extends ASTNode {
  type: 'CircleStatement';
  x: ExpressionNode;
  y: ExpressionNode;
  radius: ExpressionNode;
  color: ExpressionNode | null;
}

// PAINT Statement
export interface PaintStatementNode extends ASTNode {
  type: 'PaintStatement';
  x: ExpressionNode;
  y: ExpressionNode;
  color: ExpressionNode | null;
}

// Expression AST Nodes
export interface ExpressionWrapperNode extends ASTNode {
  type: 'Expression';
  expression: ExpressionNode;
}

export type ExpressionNode = 
  | ExpressionWrapperNode
  | BinaryExpressionNode
  | UnaryExpressionNode
  | FunctionCallNode
  | VariableNode
  | NumberLiteralNode
  | StringLiteralNode;

export interface BinaryExpressionNode extends ASTNode {
  type: 'BinaryExpression';
  operator: string;
  left: ExpressionNode;
  right: ExpressionNode;
}

export interface UnaryExpressionNode extends ASTNode {
  type: 'UnaryExpression';
  operator: string;
  operand: ExpressionNode;
}

export interface FunctionCallNode extends ASTNode {
  type: 'FunctionCall';
  name: string;
  arguments: ExpressionNode[];
}

export interface VariableNode extends ASTNode {
  type: 'Variable';
  name: string;
  subscript: ExpressionNode[] | null;
}

export interface NumberLiteralNode extends ASTNode {
  type: 'NumberLiteral';
  value: number;
}

export interface StringLiteralNode extends ASTNode {
  type: 'StringLiteral';
  value: string;
}

// Invalid Command
export interface InvalidCommandNode extends ASTNode {
  type: 'InvalidCommand';
  command: string;
}

// Utility types for lists
export type ExpressionListNode = ExpressionNode[];
export type VariableListNode = VariableNode[];
export type ConstantListNode = ConstantNode[];