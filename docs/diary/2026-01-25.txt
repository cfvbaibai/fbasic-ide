### Recent Updates (2026-01-25)

**Explicit Character Sequence Configuration**:
- ‚úÖ Created `characterSequenceConfig.ts` with explicit sprite sequences for all 16 character types
- ‚úÖ Each character has direction-specific sprite lists (0-8) with exact sprite names in frame order
- ‚úÖ Per-frame inversion flags (frameInversions) - one per sprite name
- ‚úÖ Frame rates and looping behavior configured per direction
- ‚úÖ Example: MARIO direction 1 (Up) alternates between normal and X-inversed LADDER

**Per-Frame Sprite Inversion Support**:
- ‚úÖ Added `FrameInversionConfig` interface to `types.ts`
- ‚úÖ Added `frameInversions?: FrameInversionConfig[]` field to `AnimationSequence`
- ‚úÖ Updated `useKonvaSpriteRenderer.ts` to use per-frame inversions with direction-level fallback
- ‚úÖ Updated `useSpriteRendering.ts` to support per-frame inversions
- ‚úÖ Each frame can now have its own inversion flags (invertX, invertY)

**CharacterAnimationBuilder Refactoring**:
- ‚úÖ Refactored to use config-based approach (`buildSequencesFromConfig`, `buildDirectionMappingsFromConfig`)
- ‚úÖ Falls back to old method for characters without explicit config
- ‚úÖ Improved accuracy and maintainability of character animations
- ‚úÖ Fixed frame inversion count mismatch for MARIO and LADY direction 4

**Phase 5 - Movement Control Commands Complete** (2026-01-25):
- ‚úÖ CUT command implemented - stops movement, keeps sprite visible
- ‚úÖ ERA command implemented - erases sprite completely
- ‚úÖ POSITION command implemented - sets initial position for next MOVE
- ‚úÖ MOVE(n) function implemented - returns -1 if moving, 0 if complete
- ‚úÖ XPOS(n) function implemented - returns current X position
- ‚úÖ YPOS(n) function implemented - returns current Y position

**Bug Fix - CUT Position Preservation** (2026-01-25):
- üêõ **Fixed**: MOVE after CUT was resetting sprite to original position instead of preserving CUT position
- **Root Cause**: Worker's `AnimationManager.updateMovements()` is never called, so worker has stale positions. When CUT saved positions, they were initial positions, not current animated positions
- **Architecture Issue**:
  - Frontend runs animation loop and has current positions
  - Worker never updates positions (no updateMovements calls)
  - Worker was saving stale positions to storedPositions on CUT
  - Next MOVE used stale stored position
- **Solution**: Multi-layer position retrieval system
  1. Added sprite node refs to IDE composable (`frontSpriteNodes`, `backSpriteNodes`)
  2. Screen component syncs Konva sprite nodes to external refs after rendering
  3. STOP_MOVEMENT handler retrieves positions from Konva nodes (most accurate) before falling back to movement states
  4. Frontend sends `UPDATE_ANIMATION_POSITIONS` message to worker with actual positions
  5. Worker updates `AnimationManager.storedPositions` with current positions from frontend
  6. Next MOVE uses updated stored position
- **Files Changed**:
  - `src/core/interfaces.ts`: Added `UpdateAnimationPositionsMessage` type
  - `src/core/animation/AnimationManager.ts`: Added `updateStoredPositions()` method, removed stale position saving from `stopMovement()`
  - `src/core/BasicInterpreter.ts`: Added `getAnimationManager()` method
  - `src/features/ide/composables/useBasicIdeEnhanced.ts`: Added sprite node refs
  - `src/features/ide/composables/useBasicIdeMessageHandlers.ts`: Updated position retrieval to use Konva nodes
  - `src/features/ide/components/Screen.vue`: Added external sprite node sync
  - `src/features/ide/components/ScreenTab.vue`: Pass through sprite node props
  - `src/features/ide/components/RuntimeOutput.vue`: Pass through sprite node props
  - `src/features/ide/IdePage.vue`: Connect composable to components
  - `public/basic-interpreter-worker.js`: Added UPDATE_ANIMATION_POSITIONS message handler
- **Impact**: MOVE after CUT now correctly continues from where sprite was cut, even after animation has occurred
- ‚úÖ All executors registered in StatementRouter
- ‚úÖ Function evaluation methods added to FunctionEvaluator
- ‚úÖ Parser rules added with proper lookahead for MOVE statement vs MOVE(n) function
- ‚úÖ useMovementStateSync composable created for movement state synchronization
- ‚úÖ All TypeScript type checking passes
- ‚úÖ All ESLint checks pass

**Key Implementation Details**:
- **Parser Lookahead**: MOVE statement (MOVE n) distinguished from MOVE(n) function using lookahead gate (`LA(2) !== LParen`)
- **Function Integration**: MOVE(n), XPOS(n), YPOS(n) added to FunctionEvaluator alongside STICK and STRIG
- **AnimationManager Methods**: All required methods (stopMovement, eraseMovement, setPosition, getMovementStatus, getSpritePosition) were already implemented in Phase 3
- **Multiple Action Support**: CUT and ERA support variable arguments (n1, n2, ...) for controlling multiple sprites simultaneously
- **Position Preservation**: Multi-layer position retrieval system using Konva sprite node references ensures accurate position preservation when CUT is executed after animation

### Completed (2026-01-25)

**Phase 1 Achievements** (‚úÖ Complete):
- ‚úÖ Canvas infrastructure fully extended with multi-layer rendering
- ‚úÖ Sprite type definitions complete with all necessary interfaces
- ‚úÖ Tile caching implemented for performance optimization

**Phase 2 Achievements** (‚úÖ Complete):
- ‚úÖ Sprite state manager handles 8 sprite slots efficiently
- ‚úÖ Character set to tile conversion working correctly
- ‚úÖ DEF SPRITE and SPRITE executors implemented with full validation
- ‚úÖ Parser rules added and integrated into statement router
- ‚úÖ Rendering pipeline supports static sprites with priority layering
- ‚úÖ SPRITE ON/OFF commands implemented (visibility control)
- ‚úÖ Sprite operations work independently of SPRITE ON/OFF state
- ‚úÖ Rendering layer checks sprite enabled flag before drawing
- ‚úÖ SPRITE OFF stops rendering but preserves sprite state
- ‚úÖ **Table A lookup implemented** - CHR$(n) correctly uses sprite table, not background table
- ‚úÖ **CHR$ expression parsing** - Handles `CHR$(0)+CHR$(1)+...` correctly
- ‚úÖ **Transparency support** - Value 0 pixels render as transparent using ImageBitmap + drawImage
- ‚úÖ **Sprite state synchronization** - States passed from web worker to main thread
- ‚úÖ All TypeScript type checking passes
- ‚úÖ All ESLint checks pass

**Key Accomplishments**:
- No technical debt introduced
- Clean separation of concerns maintained
- All files respect 500-line limit
- Full type safety throughout

**Phase 4 Achievements** (‚úÖ Complete - 2026-01-25):
- ‚úÖ CharacterAnimationBuilder implemented with sequence extraction and direction mapping
- ‚úÖ **Explicit character sequence configuration** (`characterSequenceConfig.ts`) - All 16 character types have explicit configs
- ‚úÖ **Per-frame sprite inversion support** - FrameInversionConfig interface and frameInversions field added
- ‚úÖ Animation sequences built from explicit configs (with fallback to CHARACTER_SPRITES data)
- ‚úÖ Frame animation logic added to updateMovements() in Screen.vue
- ‚úÖ renderAnimatedSprite() updated to render actual character sprite tiles with per-frame inversions
- ‚úÖ Direction-to-sequence mapping with automatic inversion (left = WALK + X inversion)
- ‚úÖ Character animation configs cached for performance
- ‚úÖ Support for 8√ó8 and 16√ó16 sprite frames
- ‚úÖ Frame looping using modulo operation
- ‚úÖ Sprite renderers (useKonvaSpriteRenderer, useSpriteRendering) support per-frame inversions
- ‚úÖ All TypeScript type checking passes
- ‚úÖ All ESLint checks pass

**Phase 3 Achievements** (‚úÖ Complete - 2026-01-25):
- ‚úÖ AnimationManager implemented with real-time command communication
- ‚úÖ DEF MOVE and MOVE commands fully functional
- ‚úÖ Real-time animation command messaging between worker and main thread
- ‚úÖ requestAnimationFrame animation loop for smooth movement
- ‚úÖ Sequential movement execution with PAUSE timing support
- ‚úÖ Movement state synchronization and merging
- ‚úÖ Visual feedback with colored rectangles (placeholder for Phase 4)
- ‚úÖ Unique starting positions for each action slot
- ‚úÖ Screen bounds clamping for movements
- ‚úÖ Sample test program (moveTest) demonstrating sequential movements
- ‚úÖ All TypeScript type checking passes
- ‚úÖ All ESLint checks pass

**Issues Resolved** (2026-01-25):

1. **Sprite States Not Displaying**
   - **Problem**: Sprites defined in web worker but not visible on screen
   - **Root Cause**: Sprite states not passed from web worker to main thread
   - **Solution**: 
     - Added `spriteStates` and `spriteEnabled` to `ExecutionResult` interface
     - Updated `WebWorkerInterpreter` to extract sprite states from context
     - Updated `useBasicIdeEnhanced` to receive and manage sprite states
     - Passed sprite states through component hierarchy

2. **Table A vs Table B Lookup Issue**
   - **Problem**: `CHR$(0)` was looking up tiles from background table (Table B) instead of sprite table (Table A)
   - **Root Cause**: `convertCharacterSetToTiles()` used `getBackgroundItemByCode()` which looks up Table B
   - **Solution**:
     - Created `src/shared/utils/spriteLookup.ts` with sprite-specific lookup functions
     - `getSpriteTileByCode()` - Finds sprite tiles from CHARACTER_SPRITES array
     - `getSpriteTilesByCodes()` - Handles multi-tile sprites with exact matching
     - Updated `convertCharacterSetToTiles()` to use sprite lookup

3. **CHR$ Expression Parsing**
   - **Problem**: `CHR$(0)+CHR$(1)+CHR$(2)+CHR$(3)` evaluated as string concatenation, producing invalid codes
   - **Root Cause**: Expression evaluator treated CHR$ expressions as string concatenation
   - **Solution**:
     - Added `extractChrCodesFromExpression()` method in `DefSpriteExecutor`
     - Recursively traverses expression CST to extract CHR$ function calls
     - Directly extracts character codes from CHR$ arguments
     - Falls back to normal evaluation if no CHR$ expressions found

4. **Transparency Not Working (Black Pixels)**
   - **Problem**: Sprite pixels with value 0 rendered as black instead of transparent
   - **Root Cause**: 
     - Canvas context used `alpha: false`, which doesn't support transparency
     - `putImageData()` doesn't perform alpha blending - directly replaces pixels
   - **Solution**:
     - Changed canvas context to `alpha: true` in `renderScreenLayers()`
     - Switched from `ImageData` + `putImageData()` to `ImageBitmap` + `drawImage()`
     - `drawImage()` properly supports alpha blending for transparent pixels
     - Initialize all pixels to transparent (alpha = 0) before rendering
     - Updated all rendering functions to async for `createImageBitmap()`

5. **Movements Appearing Simultaneously Instead of Sequentially**
   - **Problem**: All movements appeared at once after all MOVE commands completed, ignoring PAUSE timing
   - **Root Cause**: Movement states were only sent to main thread after entire program execution completed
   - **Solution**:
     - Implemented real-time `AnimationCommand` messaging via `sendAnimationCommand()` in device adapter
     - `AnimationManager.startMovement()` sends `START_MOVEMENT` command immediately when MOVE executes
     - Main thread processes commands in real-time via `handleAnimationCommandMessage()`
     - Movements now appear and start sequentially as each MOVE command executes, respecting PAUSE delays

**Technical Solutions Summary**:
- ‚úÖ Created `spriteLookup.ts` for Table A sprite tile lookup
- ‚úÖ Enhanced `DefSpriteExecutor` with CHR$ expression extraction
- ‚úÖ Updated rendering to use ImageBitmap with alpha support
- ‚úÖ Added sprite state fields to ExecutionResult interface
- ‚úÖ Implemented async rendering pipeline for ImageBitmap creation
- ‚úÖ Updated sprite state synchronization across web worker and main thread
- ‚úÖ Correct SPRITE ON/OFF semantics (visibility control, not operation gating)
- ‚úÖ Implemented real-time animation command communication architecture
- ‚úÖ Created AnimationManager with command-based state management
- ‚úÖ Added requestAnimationFrame animation loop for smooth movement
- ‚úÖ Implemented movement state merging to preserve active movement positions
- Ready for Phase 4: Animation Sequences (frame cycling)

**Important Design Decisions**:
- **SPRITE ON/OFF controls visibility only**, not whether sprite operations can execute
- DEF SPRITE and SPRITE commands work regardless of SPRITE ON/OFF state
- Sprites can be defined and positioned when SPRITE OFF
- SPRITE ON makes them visible, SPRITE OFF hides them
- This matches Family BASIC behavior where sprite state persists independently of display state

- **Real-time Animation Commands**: Movements are sent as commands from web worker to main thread immediately when MOVE executes, not batched after program completion. This enables sequential execution with proper PAUSE timing.
- **Main Thread Animation Loop**: Position updates happen on the main thread using requestAnimationFrame for smooth rendering, while movement definitions and triggers remain in the web worker.
- **State Merging**: When new movement states arrive from the worker, they are merged with existing local states to preserve current positions of active movements.
